{
  "markdown": "# Joins & Relationships\n\nConnect semantic tables to enable powerful multi-model queries. BSL provides flexible joining capabilities that allow you to query dimensions and measures across related tables using intuitive dot notation.\n\n## Join Types\n\nBSL supports three types of joins to handle different relationship patterns between your semantic tables.\n\n### SQL-style Joins\n\nUse the `Join` class for standard SQL-style joins with full control over join conditions and types.\n\n```python\nfrom boring_semantic_layer import Join\n\n# Define carriers model\ncarriers_sm = SemanticModel(\n    name=\"carriers\",\n    table=carriers_tbl,\n    dimensions={\n        \"code\": lambda t: t.code,\n        \"name\": lambda t: t.name\n    }\n)\n\n# Join with flights\nflights_sm = SemanticModel(\n    name=\"flights\",\n    table=flights_tbl,\n    dimensions={\"carrier\": lambda t: t.carrier},\n    measures={\"flight_count\": lambda t: t.count()},\n    joins={\n        \"carriers\": Join(\n            model=carriers_sm,\n            on=lambda left, right: left.carrier == right.code,\n            how=\"left\"  # or \"inner\", \"right\", \"outer\"\n        )\n    }\n)\n\n# Query across joined models\nflights_sm.query(\n    dimensions=['carriers.name'],\n    measures=['flight_count']\n).execute()\n```\n\nThe `how` parameter accepts standard SQL join types: `\"left\"`, `\"inner\"`, `\"right\"`, or `\"outer\"`.\n\n### One-to-One Joins\n\nUse `join_one` for relationships where each row matches exactly one row in the joined table. This is a convenience function that simplifies the syntax for one-to-one relationships.\n\n```python\nfrom boring_semantic_layer import join_one\n\nflights_sm = SemanticModel(\n    table=flights_tbl,\n    joins={\n        \"carrier_details\": join_one(\n            model=carriers_sm,\n            on=lambda left, right: left.carrier == right.code\n        )\n    }\n)\n```\n\n### Cross Joins\n\nUse `join_cross` to create cartesian products for special analytical needs, such as generating all possible combinations of values.\n\n```python\nfrom boring_semantic_layer import join_cross\n\n# Cross join for generating all combinations\nflights_sm = SemanticModel(\n    table=flights_tbl,\n    joins={\n        \"all_carriers\": join_cross(model=carriers_sm)\n    }\n)\n```\n\n## Querying Across Joined Models\n\nOnce you've defined joins between semantic tables, you can query dimensions and measures from multiple models in a single query. Use dot notation to reference fields from joined models.\n\n```python\n# Query dimensions and measures from joined models\nresult = flights_sm.query(\n    dimensions=[\n        'origin',                  # From flights\n        'carriers.name',           # From joined carriers\n        'carriers.nickname'        # Also from carriers\n    ],\n    measures=[\n        'flight_count',            # From flights\n        'carriers.carrier_count'   # From carriers\n    ]\n).execute()\n```\n\nThe dot notation syntax is: `{model_name}.{dimension_or_measure}`. Fields without a prefix are assumed to come from the base model.\n\n## Handling Name Conflicts\n\nWhen multiple models have dimensions or measures with the same name, use the model prefix to disambiguate and make your queries explicit.\n\n```python\n# Both models have a 'name' dimension\nresult = flights_sm.query(\n    dimensions=[\n        'flights.name',    # Explicitly from flights\n        'carriers.name'    # Explicitly from carriers\n    ],\n    measures=['flight_count']\n).execute()\n```\n\nUsing explicit model prefixes is recommended even when there are no conflicts, as it makes your queries more readable and maintainable.\n\n## Examples\n\n### Example 1: Flight Analysis with Carrier Details\n\nThis example shows how to analyze flight data enriched with carrier information.\n\n```python\nfrom boring_semantic_layer import SemanticModel, Join\n\n# Define the carriers semantic model\ncarriers_sm = SemanticModel(\n    name=\"carriers\",\n    table=carriers_tbl,\n    dimensions={\n        \"code\": lambda t: t.code,\n        \"name\": lambda t: t.name,\n        \"nickname\": lambda t: t.nickname\n    },\n    measures={\n        \"carrier_count\": lambda t: t.count()\n    }\n)\n\n# Define flights model with join to carriers\nflights_sm = SemanticModel(\n    name=\"flights\",\n    table=flights_tbl,\n    dimensions={\n        \"carrier\": lambda t: t.carrier,\n        \"origin\": lambda t: t.origin,\n        \"destination\": lambda t: t.dest\n    },\n    measures={\n        \"flight_count\": lambda t: t.count(),\n        \"avg_delay\": lambda t: t.dep_delay.mean()\n    },\n    joins={\n        \"carriers\": Join(\n            model=carriers_sm,\n            on=lambda left, right: left.carrier == right.code,\n            how=\"left\"\n        )\n    }\n)\n\n# Query flight statistics by carrier name\nresult = flights_sm.query(\n    dimensions=['carriers.name', 'origin'],\n    measures=['flight_count', 'avg_delay']\n).execute()\n```\n\n### Example 2: Multi-Model Query with Filters\n\nThis example demonstrates filtering and aggregating across joined models.\n\n```python\n# Query with filters on both models\nresult = flights_sm.query(\n    dimensions=['carriers.name', 'destination'],\n    measures=['flight_count', 'avg_delay']\n).where(\n    lambda t: (t.origin == 'JFK') & (t.carriers.name.like('%American%'))\n).execute()\n\n# The filter can reference both the base model and joined models\n# using the same dot notation as in the select clause\n```\n\nThis consolidated approach to joins enables you to build complex analytical queries while maintaining clean, readable code.\n",
  "queries": {},
  "files": {}
}