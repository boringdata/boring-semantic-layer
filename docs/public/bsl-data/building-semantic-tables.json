{
  "markdown": "# Defining Semantic Tables\n\nA Semantic Table is the core building block of BSL. It transforms a raw Ibis table into a reusable, self-documenting data model by defining dimensions (attributes to group by) and measures (aggregations and calculations).\n\n## Creating a Semantic Table\n\nStart with any Ibis table and convert it to a Semantic Table by defining dimensions and measures using lambda expressions:\n\n```python\nimport ibis\nfrom boring_semantic_layer import SemanticModel\n\n# 1. Start with an Ibis table\nflights_tbl = ibis.table(\n    name=\"flights\",\n    schema={\"origin\": \"string\", \"carrier\": \"string\", \"distance\": \"int64\"}\n)\n\n# 2. Convert to a Semantic Table\nflights_sm = SemanticModel(\n    name=\"flights\",\n    table=flights_tbl,\n    dimensions={\n        'origin': lambda t: t.origin,\n        'carrier': lambda t: t.carrier\n    },\n    measures={\n        'flight_count': lambda t: t.count(),\n        'total_distance': lambda t: t.distance.sum()\n    }\n)\n```\n\n## Adding Dimensions\n\nDimensions are attributes you can group by in your queries. Define them using lambda expressions that reference columns in your Ibis table.\n\n### Basic Dimensions\n\n```python\nfrom boring_semantic_layer import SemanticModel\n\nflights_sm = SemanticModel(\n    table=flights_tbl,\n    dimensions={\n        'origin': lambda t: t.origin,\n        'destination': lambda t: t.dest,\n        'year': lambda t: t.year\n    }\n)\n```\n\n### Dimensions with Descriptions\n\nAdd descriptions to make your models self-documenting and AI-friendly:\n\n```python\nfrom boring_semantic_layer import SemanticModel, DimensionSpec\n\nflights_sm = SemanticModel(\n    table=flights_tbl,\n    dimensions={\n        \"origin\": DimensionSpec(\n            expr=lambda t: t.origin,\n            description=\"Origin airport code where the flight departed\"\n        ),\n        \"destination\": DimensionSpec(\n            expr=lambda t: t.dest,\n            description=\"Destination airport code where the flight arrived\"\n        ),\n        \"year\": DimensionSpec(\n            expr=lambda t: t.year,\n            description=\"Year of the flight\"\n        )\n    }\n)\n```\n\n## Adding Measures\n\nMeasures are aggregations and calculations that can be computed from your data. They use lambda expressions that return Ibis aggregation expressions.\n\n### Lambda Expressions\n\nDefine measures using common aggregation functions:\n\n```python\nmeasures={\n    'total_flights': lambda t: t.count(),\n    'total_distance': lambda t: t.distance.sum(),\n    'avg_distance': lambda t: t.distance.mean(),\n    'max_delay': lambda t: t.dep_delay.max()\n}\n```\n\n### Measures with Descriptions\n\nUse `MeasureSpec` to add descriptions for better documentation:\n\n```python\nfrom boring_semantic_layer import MeasureSpec\n\nmeasures={\n    \"flight_count\": MeasureSpec(\n        expr=lambda t: t.count(),\n        description=\"Total number of flights\"\n    ),\n    \"avg_distance\": MeasureSpec(\n        expr=lambda t: t.distance.mean(),\n        description=\"Average flight distance in miles\"\n    )\n}\n```\n\n### Referencing Other Measures\n\nBuild complex measures by referencing other measures you've already defined:\n\n```python\nmeasures={\n    'total_distance': lambda t: t.distance.sum(),\n    'flight_count': lambda t: t.count(),\n    # Reference other measures\n    'avg_distance_per_flight': lambda t: t.total_distance / t.flight_count\n}\n```\n\n## Best Practices\n\n- **Use descriptive names**: Choose dimension and measure names that clearly indicate what they represent\n- **Add descriptions**: Use `DimensionSpec` and `MeasureSpec` with descriptions to make your models self-documenting\n- **Leverage measure composition**: Build complex metrics by referencing simpler measures rather than duplicating logic\n- **Keep dimensions simple**: Dimensions should represent groupable attributes; save calculations for measures\n",
  "queries": {}
}