{
  "current_library_version": "0.3.4",
  "metadata_version": "0.0.0",
  "git_state": {
    "commit": "52b7dfba8eeac5424b9521bc978e5915b9ffd494",
    "diff": "diff --git a/examples/roundtrip_serialization_to_disk.py b/examples/roundtrip_serialization_to_disk.py\nindex a0c8f95..38947af 100644\n--- a/examples/roundtrip_serialization_to_disk.py\n+++ b/examples/roundtrip_serialization_to_disk.py\n@@ -37,7 +37,7 @@ def main():\n \n     print(f\"Expression saved to disk with hash: {expr_hash}\")\n \n-    roundtrip_expr = from_xorq(build_manager.load_expr(expr_hash))\n+    loaded_xorq_expr = build_manager.load_expr(expr_hash)\n \n     print(\"Expression successfully loaded from disk\")\n \n@@ -45,11 +45,16 @@ def main():\n     original_result = query.execute()\n     print(original_result)\n \n-    print(\"\\nExecuting roundtrip expression:\")\n-    roundtrip_result = roundtrip_expr.execute()\n+    print(\"\\nExecuting roundtrip expression (via xorq):\")\n+    # Execute the loaded xorq expression directly to avoid ibis/xorq type mismatches\n+    roundtrip_result = loaded_xorq_expr.execute()\n     print(roundtrip_result)\n \n-    print(\"\\nResults match:\", original_result.equals(roundtrip_result))\n+    # Sort both for comparison\n+    original_sorted = original_result.sort_values([\"carrier\", \"origin\"]).reset_index(drop=True)\n+    roundtrip_sorted = roundtrip_result.sort_values([\"carrier\", \"origin\"]).reset_index(drop=True)\n+\n+    print(\"\\nResults match:\", original_sorted.equals(roundtrip_sorted))\n \n \n if __name__ == \"__main__\":\ndiff --git a/src/boring_semantic_layer/utils.py b/src/boring_semantic_layer/utils.py\nindex 4f93663..dca7456 100644\n--- a/src/boring_semantic_layer/utils.py\n+++ b/src/boring_semantic_layer/utils.py\n@@ -197,10 +197,12 @@ def expr_to_ibis_string(fn: Callable) -> Result[str, Exception]:\n                 return deferred_check.unwrap()\n             raise ValueError(f\"Expected callable or Deferred, got {type(fn)}\")\n \n+        # Prioritize source extraction to handle ibis.desc/asc properly\n+        # Then fall back to introspection for simple deferred expressions\n         checks = [\n             lambda: _check_closure_vars(fn),\n-            lambda: _try_ibis_introspection(fn).value_or(Nothing),\n             lambda: _try_source_extraction(fn),\n+            lambda: _try_ibis_introspection(fn).value_or(Nothing),\n         ]\n \n         for check in checks:\n@@ -224,9 +226,28 @@ def ibis_string_to_expr(expr_str: str) -> Result[Callable, Exception]:\n         # This allows it to work with BSL's _Resolver object\n         lambda_str = f\"lambda t: {t_expr}\"\n \n-        # Compile and return the lambda\n+        # Compile and return the lambda with necessary imports in context\n+        # Import both regular ibis and xorq's vendored ibis for compatibility\n+        import ibis\n+        from ibis import _\n+\n+        try:\n+            from xorq.vendor import ibis as xorq_ibis\n+            from xorq.vendor.ibis import _ as xorq_deferred\n+            eval_context = {\n+                \"ibis\": ibis,\n+                \"_\": _,\n+                \"xorq_ibis\": xorq_ibis,\n+            }\n+        except ImportError:\n+            # xorq not available, use regular ibis only\n+            eval_context = {\n+                \"ibis\": ibis,\n+                \"_\": _,\n+            }\n+\n         code = compile(lambda_str, \"<ibis_expr>\", \"eval\")\n-        return eval(code)  # noqa: S307\n+        return eval(code, eval_context)  # noqa: S307\n \n     return do_convert()\n \ndiff --git a/src/boring_semantic_layer/window_compat.py b/src/boring_semantic_layer/window_compat.py\nindex 30ac17b..0c60fd3 100644\n--- a/src/boring_semantic_layer/window_compat.py\n+++ b/src/boring_semantic_layer/window_compat.py\n@@ -1,16 +1,19 @@\n-\"\"\"Compatibility layer for window functions between regular and vendored ibis (9.5.0)\"\"\"\n+\"\"\"Compatibility layer for window functions between regular and vendored ibis.\n \n-from __future__ import annotations\n+This compatibility layer is only needed for ibis version 10.0.0 and greater.\n+\"\"\"\n \n-try:\n-    import ibis\n-    _IBIS_AVAILABLE = True\n-except ImportError:\n-    _IBIS_AVAILABLE = False\n+from __future__ import annotations\n \n+import ibis\n import xorq.vendor.ibis as xibis\n+from packaging.version import Version\n from xorq.vendor.ibis.expr.types.generic import Value as XorqValue\n \n+# Check if ibis version is 10.0.0 or greater\n+_IBIS_VERSION = Version(ibis.__version__)\n+_NEEDS_COMPAT = _IBIS_VERSION >= Version(\"10.0.0\")\n+\n \n def _extract_value(boundary):\n     \"\"\"Extract the numeric value from a window boundary object.\n@@ -25,7 +28,6 @@ def _extract_value(boundary):\n         return None\n \n     value = boundary.value\n-    # Handle nested value attribute (e.g., boundary.value.value)\n     if hasattr(value, 'value'):\n         value = value.value\n \n@@ -33,18 +35,6 @@ def _extract_value(boundary):\n \n \n def _process_rows_frame(window, params):\n-    \"\"\"Process ROWS frame type window bounds.\n-\n-    For ROWS frames:\n-    - start=0 means current row (no preceding needed)\n-    - start<0 means N rows before current (preceding=abs(N))\n-    - end=0 means current row (following=0)\n-    - end>0 means N rows after current (following=N)\n-\n-    Args:\n-        window: The ibis window object\n-        params: Dictionary to populate with window parameters\n-    \"\"\"\n     start_val = _extract_value(window.start)\n     if start_val is not None and start_val != 0:\n         params['preceding'] = abs(start_val)\n@@ -55,16 +45,6 @@ def _process_rows_frame(window, params):\n \n \n def _process_range_frame(window, params):\n-    \"\"\"Process RANGE frame type window bounds.\n-\n-    For RANGE frames:\n-    - bounds are relative to the current row's value in the ORDER BY expression\n-    - start/end=0 means current value (no preceding/following)\n-\n-    Args:\n-        window: The ibis window object\n-        params: Dictionary to populate with window parameters\n-    \"\"\"\n     start_val = _extract_value(window.start)\n     if start_val is not None and start_val != 0:\n         params['preceding'] = abs(start_val)\n@@ -75,40 +55,20 @@ def _process_range_frame(window, params):\n \n \n def convert_window_to_xorq(window):\n-    \"\"\"Convert a regular ibis window to a xorq-compatible window.\n-\n-    This function handles conversion between regular ibis LegacyWindowBuilder\n-    objects and xorq's vendored ibis window objects. It preserves:\n-    - Group by columns\n-    - Order by columns\n-    - Frame type (ROWS vs RANGE)\n-    - Frame bounds (preceding/following)\n-\n-    Args:\n-        window: An ibis or xorq window object\n-\n-    Returns:\n-        A xorq-compatible window object, or the original if already compatible\n-        or if ibis is not available\n-    \"\"\"\n-    # Already a xorq window - no conversion needed\n     if isinstance(window, xibis.expr.builders.LegacyWindowBuilder):\n         return window\n \n-    # Only convert if ibis is available and window is a regular ibis window\n-    if not (_IBIS_AVAILABLE and isinstance(window, ibis.expr.builders.LegacyWindowBuilder)):\n+    if not (_NEEDS_COMPAT and isinstance(window, ibis.expr.builders.LegacyWindowBuilder)):\n         return window\n \n     params = {}\n \n-    # Extract grouping and ordering columns\n     if window.groupings:\n         params['group_by'] = window.groupings\n \n     if window.orderings:\n         params['order_by'] = window.orderings\n \n-    # Process frame bounds based on frame type\n     if window.how == 'rows':\n         _process_rows_frame(window, params)\n     elif window.how == 'range':\n@@ -117,61 +77,36 @@ def convert_window_to_xorq(window):\n     return xibis.window(**params)\n \n \n-# Store the original method before patching\n _original_xorq_over = XorqValue.over\n _original_ibis_over = None\n _patch_installed = False\n \n-# Store the original ibis functions\n-_original_ibis_window = None if not _IBIS_AVAILABLE else ibis.window\n-_original_ibis_desc = None if not _IBIS_AVAILABLE else ibis.desc\n-_original_ibis_asc = None if not _IBIS_AVAILABLE else ibis.asc\n+_original_ibis_window = ibis.window\n+_original_ibis_desc = ibis.desc\n+_original_ibis_asc = ibis.asc\n \n \n def _is_xorq_expr(expr):\n-    \"\"\"Check if an expression is from xorq's vendored ibis.\n-\n-    Args:\n-        expr: The expression to check\n-\n-    Returns:\n-        True if the expression is from xorq's vendored ibis, False otherwise\n-    \"\"\"\n     if not hasattr(expr, '__class__'):\n         return False\n \n-    # Check if it's a xorq Value expression\n     if isinstance(expr, XorqValue):\n         return True\n \n-    # Check module path - xorq's vendored ibis still uses 'ibis' as module name\n-    # but the actual module object is different\n     import sys\n     if hasattr(expr, '__module__'):\n         expr_module_name = expr.__module__.split('.')[0]\n         if expr_module_name == 'ibis':\n-            # Check if it's from xorq by comparing the module object\n             expr_module = sys.modules.get(expr.__module__)\n             if expr_module:\n-                # Get the root ibis module\n                 root_parts = expr.__module__.split('.')\n                 root_module = sys.modules.get(root_parts[0])\n-                # Compare with xorq's vendored ibis\n                 return root_module is xibis\n \n     return False\n \n \n def _contains_xorq_exprs(*args, **kwargs):\n-    \"\"\"Check if any arguments contain xorq expressions.\n-\n-    Args:\n-        *args: Positional arguments to check\n-        **kwargs: Keyword arguments to check\n-\n-    Returns:\n-        True if any argument is or contains a xorq expression\n-    \"\"\"\n     def check_value(val):\n         if val is None:\n             return False\n@@ -185,84 +120,31 @@ def _contains_xorq_exprs(*args, **kwargs):\n \n \n def _patched_ibis_window(**kwargs):\n-    \"\"\"Patched version of ibis.window() that accepts xorq expressions.\n-\n-    When xorq expressions are detected in the arguments, this function\n-    uses xorq's window function instead of regular ibis's window function.\n-\n-    Args:\n-        **kwargs: Window specification parameters\n-\n-    Returns:\n-        A window object (either regular ibis or xorq depending on input)\n-    \"\"\"\n-    # If any arguments contain xorq expressions, use xorq's window function\n     if _contains_xorq_exprs(**kwargs):\n         return xibis.window(**kwargs)\n \n-    # Otherwise use the original ibis.window\n     return _original_ibis_window(**kwargs)\n \n \n def _patched_ibis_desc(expr):\n-    \"\"\"Patched version of ibis.desc() that accepts xorq expressions.\n-\n-    Args:\n-        expr: Expression to sort in descending order\n-\n-    Returns:\n-        A sort key for descending order\n-    \"\"\"\n     if _is_xorq_expr(expr):\n         return xibis.desc(expr)\n     return _original_ibis_desc(expr)\n \n \n def _patched_ibis_asc(expr):\n-    \"\"\"Patched version of ibis.asc() that accepts xorq expressions.\n-\n-    Args:\n-        expr: Expression to sort in ascending order\n-\n-    Returns:\n-        A sort key for ascending order\n-    \"\"\"\n     if _is_xorq_expr(expr):\n         return xibis.asc(expr)\n     return _original_ibis_asc(expr)\n \n \n def _is_xorq_window(window):\n-    \"\"\"Check if a window is from xorq's vendored ibis.\n-\n-    Args:\n-        window: The window to check\n-\n-    Returns:\n-        True if the window is from xorq's vendored ibis, False otherwise\n-    \"\"\"\n     if window is None:\n         return False\n     return isinstance(window, xibis.expr.builders.LegacyWindowBuilder)\n \n \n def _patched_xorq_over(self, window=None, *, rows=None, range=None, group_by=None, order_by=None):\n-    \"\"\"Patched version of xorq Value.over() that accepts both regular and xorq windows.\n-\n-    This wrapper automatically converts regular ibis windows to xorq-compatible\n-    windows before calling the original over() method.\n-\n-    Args:\n-        self: The Value expression instance\n-        window: A window specification (ibis or xorq)\n-        rows: Optional row-based window frame specification\n-        range: Optional range-based window frame specification\n-        group_by: Optional grouping columns\n-        order_by: Optional ordering columns\n-\n-    Returns:\n-        The result of calling the original over() method with converted window\n-    \"\"\"\n     if window is not None:\n         window = convert_window_to_xorq(window)\n \n@@ -277,25 +159,6 @@ def _patched_xorq_over(self, window=None, *, rows=None, range=None, group_by=Non\n \n \n def _patched_ibis_over(self, window=None, *, rows=None, range=None, group_by=None, order_by=None):\n-    \"\"\"Patched version of regular ibis Value.over() that accepts xorq windows.\n-\n-    When a xorq window is detected, this converts the regular ibis expression\n-    to xorq using from_ibis(), then applies the window operation in xorq land.\n-\n-    This ensures we only convert in one direction: regular ibis \u2192 xorq.\n-\n-    Args:\n-        self: The Value expression instance\n-        window: A window specification (ibis or xorq)\n-        rows: Optional row-based window frame specification\n-        range: Optional range-based window frame specification\n-        group_by: Optional grouping columns\n-        order_by: Optional ordering columns\n-\n-    Returns:\n-        The result of calling the over() method (may be xorq expression if window was xorq)\n-    \"\"\"\n-    # If window is a xorq window, convert self to xorq and use xorq's over()\n     if window is not None and _is_xorq_window(window):\n         from xorq.common.utils.ibis_utils import from_ibis\n         xorq_expr = from_ibis(self)\n@@ -329,33 +192,17 @@ def install_window_compatibility():\n        (converts the expression to xorq using from_ibis)\n     4. regular ibis.desc() and ibis.asc() to accept xorq expressions\n \n-    The key principle: conversions only go in one direction (regular ibis \u2192 xorq).\n-    We never convert from xorq back to regular ibis.\n-\n-    This allows code written with regular ibis to work seamlessly with\n-    xorq's vendored ibis expressions without any code changes.\n-\n-    The patch is only installed if regular ibis is available in the environment.\n-    If ibis is not available, the compatibility layer is not needed since there\n-    are no regular ibis expressions to convert.\n-\n-    Note:\n-        This function is idempotent - calling it multiple times has no effect\n-        after the first installation.\n+    Only installs the patch if ibis version is 10.0.0 or greater.\n     \"\"\"\n     global _patch_installed, _original_ibis_over\n \n-    if _IBIS_AVAILABLE and not _patch_installed:\n-        # Store the original regular ibis Value.over() method\n+    if _NEEDS_COMPAT and not _patch_installed:\n         _original_ibis_over = ibis.expr.types.generic.Value.over\n \n-        # Patch xorq's .over() method to accept regular ibis windows\n         XorqValue.over = _patched_xorq_over\n \n-        # Patch regular ibis's .over() method to accept xorq windows\n         ibis.expr.types.generic.Value.over = _patched_ibis_over\n \n-        # Patch regular ibis functions to accept xorq expressions\n         ibis.window = _patched_ibis_window\n         ibis.desc = _patched_ibis_desc\n         ibis.asc = _patched_ibis_asc\n@@ -369,19 +216,10 @@ def uninstall_window_compatibility():\n     Restores the original methods:\n     1. .over() methods to both xorq's and regular ibis Value classes\n     2. window(), desc(), asc() functions to regular ibis module\n-\n-    This is primarily useful for testing or cleanup purposes.\n-\n-    The uninstall only occurs if regular ibis is available and the patch\n-    was previously installed.\n-\n-    Note:\n-        This function is idempotent - calling it multiple times has no effect\n-        after the first uninstallation.\n     \"\"\"\n     global _patch_installed\n \n-    if _IBIS_AVAILABLE and _patch_installed:\n+    if _NEEDS_COMPAT and _patch_installed:\n         XorqValue.over = _original_xorq_over\n         ibis.expr.types.generic.Value.over = _original_ibis_over\n         ibis.window = _original_ibis_window",
    "diff_cached": "diff --git a/pyproject.toml b/pyproject.toml\nindex ecc2ba2..13022f7 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -9,7 +9,8 @@ dependencies = [\n     \"packaging\",\n     \"pyyaml>=6.0\",\n     \"returns>=0.26.0\",\n-    \"xorq>=0.3.4\"\n+    \"xorq>=0.3.4\",\n+    \"ibis-framework>=11.0.0\"\n ]\n urls = { Homepage = \"https://github.com/boringdata/boring-semantic-layer/tree/main\" }\n license = \"MIT\"\n@@ -48,6 +49,7 @@ markers = [\n [dependency-groups]\n dev = [\n     \"adbc-driver-sqlite>=1.9.0\",\n+    \"ibis-framework>=11.0.0\",\n     \"ipython>=8.37.0\",\n     \"xorq>=0.3.3\",\n ]\ndiff --git a/src/boring_semantic_layer/__init__.py b/src/boring_semantic_layer/__init__.py\nindex b7de737..62a542e 100644\n--- a/src/boring_semantic_layer/__init__.py\n+++ b/src/boring_semantic_layer/__init__.py\n@@ -54,8 +54,7 @@ except ImportError:\n try:\n     from .xorq_convert import from_xorq, to_xorq  # noqa: F401\n \n-    # Install window compatibility patch to allow regular ibis windows\n-    # to work with xorq's vendored ibis expressions\n+    # Install window compatibility so users can use `import ibis` with xorq backend\n     from .window_compat import install_window_compatibility\n     install_window_compatibility()\n \ndiff --git a/src/boring_semantic_layer/api.py b/src/boring_semantic_layer/api.py\nindex 2f17c97..bd084c1 100644\n--- a/src/boring_semantic_layer/api.py\n+++ b/src/boring_semantic_layer/api.py\n@@ -10,7 +10,7 @@ from collections.abc import Callable\n from typing import TYPE_CHECKING\n \n if TYPE_CHECKING:\n-    from xorq.vendor.ibis.expr import types as ir\n+    from ibis.expr import types as ir\n \n from .expr import SemanticModel\n \n@@ -29,17 +29,9 @@ def to_semantic_table(\n         A new SemanticModel wrapping the table\n \n     Note:\n-        If you pass a regular ibis.Table, it will be automatically converted to\n-        xorq's vendored ibis using from_ibis() to prevent type errors.\n+        Tables are kept in their original form (regular ibis or xorq vendored ibis)\n+        throughout semantic operations. Conversion only happens if needed at execution time.\n     \"\"\"\n-    # Convert regular ibis tables to xorq vendored ibis\n-    from xorq.vendor.ibis.expr.types import Table as XorqTable\n-\n-    if not isinstance(ibis_table, XorqTable):\n-        # This is a regular ibis table, convert it\n-        from xorq.common.utils.ibis_utils import from_ibis\n-        ibis_table = from_ibis(ibis_table)\n-\n     return SemanticModel(\n         table=ibis_table,\n         dimensions=None,\ndiff --git a/src/boring_semantic_layer/compile_all.py b/src/boring_semantic_layer/compile_all.py\nindex 0450a29..4a3218e 100644\n--- a/src/boring_semantic_layer/compile_all.py\n+++ b/src/boring_semantic_layer/compile_all.py\n@@ -4,7 +4,7 @@ from collections.abc import Iterable\n from functools import reduce\n from typing import Any\n \n-from xorq.vendor import ibis\n+import ibis\n from attrs import frozen\n from toolz import curry, pipe\n \n@@ -67,12 +67,26 @@ def _compile_binop(by_tbl, all_tbl, op: str, left: Any, right: Any):\n     return ops[op](left_val, right_val)\n \n \n+def _get_ibis_module(table):\n+    \"\"\"Detect which ibis module the table is using (regular ibis or xorq's vendored ibis).\"\"\"\n+    table_module = type(table).__module__\n+    if table_module.startswith(\"xorq.vendor.ibis\"):\n+        # Table is from xorq's vendored ibis\n+        from xorq.vendor import ibis as xorq_ibis\n+        return xorq_ibis\n+    else:\n+        # Table is from regular ibis\n+        return ibis\n+\n+\n def _compile_formula(expr: MeasureExpr, by_tbl, all_tbl):\n     \"\"\"Compile a measure expression to ibis, using functional dispatch for AggregationExpr.\"\"\"\n     from .measure_scope import AggregationExpr\n \n     if isinstance(expr, int | float):\n-        return ibis.literal(expr)\n+        # Use the same ibis module as the table to avoid mixing regular and xorq ibis\n+        ibis_module = _get_ibis_module(by_tbl)\n+        return ibis_module.literal(expr)\n     if isinstance(expr, MeasureRef):\n         return by_tbl[expr.name]\n     if isinstance(expr, AllOf):\n@@ -211,7 +225,8 @@ def _build_level_aggregations(\n @curry\n def _make_grouped_table(agg_dict: dict[str, Any], by_cols: Iterable[str], table):\n     group_exprs = [table[c] for c in by_cols]\n-    return table.group_by(group_exprs).aggregate(**agg_dict)\n+    # xorq requires at least one grouping expression, so handle empty case\n+    return table.group_by(group_exprs).aggregate(**agg_dict) if group_exprs else table.aggregate(**agg_dict)\n \n \n def _build_session_table(base_tbl, by_cols: Iterable[str], regular_measures: dict) -> Any:\ndiff --git a/src/boring_semantic_layer/convert.py b/src/boring_semantic_layer/convert.py\nindex 6e6713e..45d9815 100644\n--- a/src/boring_semantic_layer/convert.py\n+++ b/src/boring_semantic_layer/convert.py\n@@ -9,11 +9,11 @@ from __future__ import annotations\n from collections.abc import Callable\n from typing import Protocol, runtime_checkable\n \n-from xorq.vendor import ibis\n+import ibis\n from attrs import field, frozen\n-from xorq.vendor.ibis.common.collections import FrozenOrderedDict\n-from xorq.vendor.ibis.expr import types as ir\n-from xorq.vendor.ibis.expr.sql import convert\n+from ibis.common.collections import FrozenOrderedDict\n+from ibis.expr import types as ir\n+from ibis.expr.sql import convert\n \n from boring_semantic_layer.ops import (\n     SemanticAggregateOp,\n@@ -463,3 +463,4 @@ def _convert_semantic_unnest(node: SemanticUnnestOp, catalog, *args):\n         raise ValueError(f\"Failed to unnest column '{node.column}': {e}\") from e\n \n     return unpack_struct_if_needed(unnested, node.column)\n+\ndiff --git a/src/boring_semantic_layer/expr.py b/src/boring_semantic_layer/expr.py\nindex 4a1dcd7..ec355e2 100644\n--- a/src/boring_semantic_layer/expr.py\n+++ b/src/boring_semantic_layer/expr.py\n@@ -5,11 +5,11 @@ from functools import reduce\n from operator import attrgetter\n from typing import Any\n \n-from xorq.vendor import ibis\n-from xorq.vendor.ibis.common.collections import FrozenDict\n-from xorq.vendor.ibis.expr import types as ir\n-from xorq.vendor.ibis.expr.types import Table\n-from xorq.vendor.ibis.expr.types.groupby import GroupedTable\n+import ibis\n+from ibis.common.collections import FrozenDict\n+from ibis.expr import types as ir\n+from ibis.expr.types import Table\n+from ibis.expr.types.groupby import GroupedTable\n from returns.result import Success, safe\n \n from .chart import chart as create_chart\n@@ -155,14 +155,7 @@ class SemanticModel(SemanticTable):\n         description: str | None = None,\n         _source_join: Any | None = None,\n     ) -> None:\n-        # Convert regular ibis tables to xorq vendored ibis to prevent type errors\n-        from xorq.vendor.ibis.expr.types import Table as XorqTable\n-\n-        if hasattr(table, '__class__') and not isinstance(table, XorqTable):\n-            # Check if this is a regular ibis table by checking module path\n-            if hasattr(table, '__class__') and 'ibis.expr.types' in str(table.__class__.__module__):\n-                from xorq.common.utils.ibis_utils import from_ibis\n-                table = from_ibis(table)\n+        # Keep tables in regular ibis - only convert to xorq at execution time if needed\n \n         dims = FrozenDict(\n             {dim_name: _create_dimension(dim) for dim_name, dim in (dimensions or {}).items()},\n@@ -1160,3 +1153,4 @@ class SemanticProject(SemanticTable):\n         return _build_semantic_model_from_roots(\n             self.op().to_ibis(), all_roots, field_filter=set(self.fields)\n         )\n+\ndiff --git a/src/boring_semantic_layer/graph_utils.py b/src/boring_semantic_layer/graph_utils.py\nindex 92e51c6..3f6538d 100644\n--- a/src/boring_semantic_layer/graph_utils.py\n+++ b/src/boring_semantic_layer/graph_utils.py\n@@ -16,9 +16,15 @@ from xorq.vendor.ibis.common.graph import Graph\n from xorq.vendor.ibis.expr.operations.core import Node\n from xorq.vendor.ibis.expr.types import Expr as XorqExpr\n \n-# Regular ibis types\n-from ibis.expr.operations.core import Node as IbisNode\n-from ibis.expr.types import Expr as IbisExpr\n+# Regular ibis types (optional - for backward compatibility)\n+try:\n+    from ibis.expr.operations.core import Node as IbisNode\n+    from ibis.expr.types import Expr as IbisExpr\n+    _REGULAR_IBIS_AVAILABLE = True\n+except ImportError:\n+    IbisNode = None\n+    IbisExpr = None\n+    _REGULAR_IBIS_AVAILABLE = False\n \n # Functional programming utilities\n from returns.maybe import Maybe, Nothing, Some\n@@ -54,10 +60,11 @@ def to_node(maybe_expr: Any) -> Node:\n         ValueError: If the type cannot be converted to a Node\n     \"\"\"\n     # First check if it's regular ibis types (since xorq's to_node doesn't handle them)\n-    if isinstance(maybe_expr, IbisNode):\n-        return maybe_expr\n-    if isinstance(maybe_expr, IbisExpr):\n-        return maybe_expr.op()\n+    if _REGULAR_IBIS_AVAILABLE:\n+        if isinstance(maybe_expr, IbisNode):\n+            return maybe_expr\n+        if isinstance(maybe_expr, IbisExpr):\n+            return maybe_expr.op()\n \n     # Fall back to xorq's implementation for xorq types\n     return _xorq_to_node(maybe_expr)\n@@ -139,7 +146,7 @@ def walk_nodes(node_types, expr):\n         stack.extend(c for c in gen_children_of(node) if c not in visited)\n \n \n-def replace_nodes(replacer, expr) -> IbisExpr | XorqExpr:\n+def replace_nodes(replacer, expr):\n     \"\"\"Replace nodes in expression tree using a replacer function.\n \n     This wrapper ensures the result is converted back to an Expr.\ndiff --git a/src/boring_semantic_layer/ops.py b/src/boring_semantic_layer/ops.py\nindex 0282993..b435790 100644\n--- a/src/boring_semantic_layer/ops.py\n+++ b/src/boring_semantic_layer/ops.py\n@@ -4,20 +4,17 @@ from collections.abc import Callable, Iterable, Mapping, Sequence\n from functools import reduce\n from typing import TYPE_CHECKING, Any\n \n-from xorq.vendor import ibis\n-from xorq.vendor import ibis as xibis\n-import xorq.vendor.ibis.selectors as s\n+# Use regular ibis - works with both regular ibis and xorq backends\n+import ibis\n+import ibis.selectors as s\n from attrs import field, frozen\n-from xorq.vendor.ibis.common.collections import FrozenDict, FrozenOrderedDict\n-from xorq.vendor.ibis.common.deferred import Deferred as XorqDeferred\n-from xorq.vendor.ibis.expr import datatypes as dt\n-from xorq.vendor.ibis.expr import operations as ibis_ops\n-from xorq.vendor.ibis.expr import types as ir\n-from xorq.vendor.ibis.expr.operations.relations import Field, Relation\n-from xorq.vendor.ibis.expr.schema import Schema\n-\n-# Also import regular ibis Deferred to support both\n-from ibis.common.deferred import Deferred as RegularDeferred\n+from ibis.common.collections import FrozenDict, FrozenOrderedDict\n+from ibis.common.deferred import Deferred\n+from ibis.expr import datatypes as dt\n+from ibis.expr import operations as ibis_ops\n+from ibis.expr import types as ir\n+from ibis.expr.operations.relations import Field, Relation\n+from ibis.expr.schema import Schema\n \n from returns.maybe import Maybe, Nothing, Some\n from returns.result import Success, safe\n@@ -25,8 +22,9 @@ from toolz import curry\n \n \n def _is_deferred(expr) -> bool:\n-    \"\"\"Check if expression is a Deferred from either regular or vendored ibis.\"\"\"\n-    return isinstance(expr, (XorqDeferred, RegularDeferred))\n+    \"\"\"Check if expression is a Deferred.\"\"\"\n+    return isinstance(expr, Deferred)\n+\n \n from . import projection_utils\n from .compile_all import compile_grouped_with_all\n@@ -52,6 +50,10 @@ if TYPE_CHECKING:\n \n \n def _to_ibis(source: Any) -> ir.Table:\n+    \"\"\"Convert source to ibis table without forcing conversions.\n+\n+    Works with both regular ibis tables and xorq backend tables.\n+    \"\"\"\n     return source.to_ibis() if hasattr(source, \"to_ibis\") else source.to_expr()\n \n \n@@ -445,10 +447,11 @@ class SemanticTableOp(Relation):\n \n     Stores ir.Table expression directly to avoid .op() \u2192 .to_expr() conversions.\n \n-    Note: Also accepts xorq's vendored ibis tables to support optional xorq integration.\n+    Note: Accepts both regular ibis.Table and xorq's vendored ibis.Table.\n+    Regular ibis tables are automatically converted to xorq in __init__.\n     \"\"\"\n \n-    table: ir.Table\n+    table: Any  # Accepts both ir.Table and regular ibis.expr.types.Table\n     dimensions: FrozenDict[str, Dimension]\n     measures: FrozenDict[str, Measure]\n     calc_measures: FrozenDict[str, Any]\n@@ -466,8 +469,8 @@ class SemanticTableOp(Relation):\n         description: str | None = None,\n         _source_join: Any = None,\n     ) -> None:\n-        # Always use super().__init__() to ensure proper xorq/ibis initialization\n-        # This works for both regular ibis and xorq's vendored ibis\n+        # Accept both regular ibis and xorq tables without conversion\n+        # This allows using regular ibis by default, xorq only when provided\n         super().__init__(\n             table=table,\n             dimensions=FrozenDict(dimensions)\ndiff --git a/src/boring_semantic_layer/query.py b/src/boring_semantic_layer/query.py\nindex d4741e2..8715210 100644\n--- a/src/boring_semantic_layer/query.py\n+++ b/src/boring_semantic_layer/query.py\n@@ -10,9 +10,9 @@ from collections.abc import Callable, Mapping, Sequence\n from operator import eq, ge, gt, le, lt, ne\n from typing import Any, ClassVar, Literal\n \n-from xorq.vendor import ibis\n+import ibis\n from attrs import frozen\n-from xorq.vendor.ibis.common.collections import FrozenDict\n+from ibis.common.collections import FrozenDict\n from toolz import curry\n \n from .utils import safe_eval\n@@ -443,3 +443,4 @@ def query(\n         result = result.limit(limit)\n \n     return result\n+\ndiff --git a/src/boring_semantic_layer/window_compat.py b/src/boring_semantic_layer/window_compat.py\nindex 33ac813..30ac17b 100644\n--- a/src/boring_semantic_layer/window_compat.py\n+++ b/src/boring_semantic_layer/window_compat.py\n@@ -118,12 +118,136 @@ def convert_window_to_xorq(window):\n \n \n # Store the original method before patching\n-_original_over = XorqValue.over\n+_original_xorq_over = XorqValue.over\n+_original_ibis_over = None\n _patch_installed = False\n \n+# Store the original ibis functions\n+_original_ibis_window = None if not _IBIS_AVAILABLE else ibis.window\n+_original_ibis_desc = None if not _IBIS_AVAILABLE else ibis.desc\n+_original_ibis_asc = None if not _IBIS_AVAILABLE else ibis.asc\n \n-def _patched_over(self, window=None, *, rows=None, range=None, group_by=None, order_by=None):\n-    \"\"\"Patched version of .over() that accepts both regular and xorq windows.\n+\n+def _is_xorq_expr(expr):\n+    \"\"\"Check if an expression is from xorq's vendored ibis.\n+\n+    Args:\n+        expr: The expression to check\n+\n+    Returns:\n+        True if the expression is from xorq's vendored ibis, False otherwise\n+    \"\"\"\n+    if not hasattr(expr, '__class__'):\n+        return False\n+\n+    # Check if it's a xorq Value expression\n+    if isinstance(expr, XorqValue):\n+        return True\n+\n+    # Check module path - xorq's vendored ibis still uses 'ibis' as module name\n+    # but the actual module object is different\n+    import sys\n+    if hasattr(expr, '__module__'):\n+        expr_module_name = expr.__module__.split('.')[0]\n+        if expr_module_name == 'ibis':\n+            # Check if it's from xorq by comparing the module object\n+            expr_module = sys.modules.get(expr.__module__)\n+            if expr_module:\n+                # Get the root ibis module\n+                root_parts = expr.__module__.split('.')\n+                root_module = sys.modules.get(root_parts[0])\n+                # Compare with xorq's vendored ibis\n+                return root_module is xibis\n+\n+    return False\n+\n+\n+def _contains_xorq_exprs(*args, **kwargs):\n+    \"\"\"Check if any arguments contain xorq expressions.\n+\n+    Args:\n+        *args: Positional arguments to check\n+        **kwargs: Keyword arguments to check\n+\n+    Returns:\n+        True if any argument is or contains a xorq expression\n+    \"\"\"\n+    def check_value(val):\n+        if val is None:\n+            return False\n+        if _is_xorq_expr(val):\n+            return True\n+        if isinstance(val, (list, tuple)):\n+            return any(check_value(v) for v in val)\n+        return False\n+\n+    return any(check_value(arg) for arg in args) or any(check_value(v) for v in kwargs.values())\n+\n+\n+def _patched_ibis_window(**kwargs):\n+    \"\"\"Patched version of ibis.window() that accepts xorq expressions.\n+\n+    When xorq expressions are detected in the arguments, this function\n+    uses xorq's window function instead of regular ibis's window function.\n+\n+    Args:\n+        **kwargs: Window specification parameters\n+\n+    Returns:\n+        A window object (either regular ibis or xorq depending on input)\n+    \"\"\"\n+    # If any arguments contain xorq expressions, use xorq's window function\n+    if _contains_xorq_exprs(**kwargs):\n+        return xibis.window(**kwargs)\n+\n+    # Otherwise use the original ibis.window\n+    return _original_ibis_window(**kwargs)\n+\n+\n+def _patched_ibis_desc(expr):\n+    \"\"\"Patched version of ibis.desc() that accepts xorq expressions.\n+\n+    Args:\n+        expr: Expression to sort in descending order\n+\n+    Returns:\n+        A sort key for descending order\n+    \"\"\"\n+    if _is_xorq_expr(expr):\n+        return xibis.desc(expr)\n+    return _original_ibis_desc(expr)\n+\n+\n+def _patched_ibis_asc(expr):\n+    \"\"\"Patched version of ibis.asc() that accepts xorq expressions.\n+\n+    Args:\n+        expr: Expression to sort in ascending order\n+\n+    Returns:\n+        A sort key for ascending order\n+    \"\"\"\n+    if _is_xorq_expr(expr):\n+        return xibis.asc(expr)\n+    return _original_ibis_asc(expr)\n+\n+\n+def _is_xorq_window(window):\n+    \"\"\"Check if a window is from xorq's vendored ibis.\n+\n+    Args:\n+        window: The window to check\n+\n+    Returns:\n+        True if the window is from xorq's vendored ibis, False otherwise\n+    \"\"\"\n+    if window is None:\n+        return False\n+    return isinstance(window, xibis.expr.builders.LegacyWindowBuilder)\n+\n+\n+def _patched_xorq_over(self, window=None, *, rows=None, range=None, group_by=None, order_by=None):\n+    \"\"\"Patched version of xorq Value.over() that accepts both regular and xorq windows.\n \n     This wrapper automatically converts regular ibis windows to xorq-compatible\n     windows before calling the original over() method.\n@@ -142,7 +266,48 @@ def _patched_over(self, window=None, *, rows=None, range=None, group_by=None, or\n     if window is not None:\n         window = convert_window_to_xorq(window)\n \n-    return _original_over(\n+    return _original_xorq_over(\n+        self,\n+        window=window,\n+        rows=rows,\n+        range=range,\n+        group_by=group_by,\n+        order_by=order_by\n+    )\n+\n+\n+def _patched_ibis_over(self, window=None, *, rows=None, range=None, group_by=None, order_by=None):\n+    \"\"\"Patched version of regular ibis Value.over() that accepts xorq windows.\n+\n+    When a xorq window is detected, this converts the regular ibis expression\n+    to xorq using from_ibis(), then applies the window operation in xorq land.\n+\n+    This ensures we only convert in one direction: regular ibis \u2192 xorq.\n+\n+    Args:\n+        self: The Value expression instance\n+        window: A window specification (ibis or xorq)\n+        rows: Optional row-based window frame specification\n+        range: Optional range-based window frame specification\n+        group_by: Optional grouping columns\n+        order_by: Optional ordering columns\n+\n+    Returns:\n+        The result of calling the over() method (may be xorq expression if window was xorq)\n+    \"\"\"\n+    # If window is a xorq window, convert self to xorq and use xorq's over()\n+    if window is not None and _is_xorq_window(window):\n+        from xorq.common.utils.ibis_utils import from_ibis\n+        xorq_expr = from_ibis(self)\n+        return xorq_expr.over(\n+            window=window,\n+            rows=rows,\n+            range=range,\n+            group_by=group_by,\n+            order_by=order_by\n+        )\n+\n+    return _original_ibis_over(\n         self,\n         window=window,\n         rows=rows,\n@@ -155,29 +320,56 @@ def _patched_over(self, window=None, *, rows=None, range=None, group_by=None, or\n def install_window_compatibility():\n     \"\"\"Install the window compatibility monkey-patch.\n \n-    This patches xorq's vendored ibis Value.over() method to automatically\n-    convert regular ibis windows to xorq windows. This allows code written\n-    with regular ibis to work seamlessly with xorq's vendored ibis.\n+    This patches:\n+    1. xorq's vendored ibis Value.over() method to accept regular ibis windows\n+       (converts them to xorq windows using convert_window_to_xorq)\n+    2. regular ibis.window() function to return xorq windows when xorq\n+       expressions are detected in the arguments\n+    3. regular ibis Value.over() method to accept xorq windows\n+       (converts the expression to xorq using from_ibis)\n+    4. regular ibis.desc() and ibis.asc() to accept xorq expressions\n+\n+    The key principle: conversions only go in one direction (regular ibis \u2192 xorq).\n+    We never convert from xorq back to regular ibis.\n+\n+    This allows code written with regular ibis to work seamlessly with\n+    xorq's vendored ibis expressions without any code changes.\n \n     The patch is only installed if regular ibis is available in the environment.\n     If ibis is not available, the compatibility layer is not needed since there\n-    are no regular ibis windows to convert.\n+    are no regular ibis expressions to convert.\n \n     Note:\n         This function is idempotent - calling it multiple times has no effect\n         after the first installation.\n     \"\"\"\n-    global _patch_installed\n+    global _patch_installed, _original_ibis_over\n \n     if _IBIS_AVAILABLE and not _patch_installed:\n-        XorqValue.over = _patched_over\n+        # Store the original regular ibis Value.over() method\n+        _original_ibis_over = ibis.expr.types.generic.Value.over\n+\n+        # Patch xorq's .over() method to accept regular ibis windows\n+        XorqValue.over = _patched_xorq_over\n+\n+        # Patch regular ibis's .over() method to accept xorq windows\n+        ibis.expr.types.generic.Value.over = _patched_ibis_over\n+\n+        # Patch regular ibis functions to accept xorq expressions\n+        ibis.window = _patched_ibis_window\n+        ibis.desc = _patched_ibis_desc\n+        ibis.asc = _patched_ibis_asc\n+\n         _patch_installed = True\n \n \n def uninstall_window_compatibility():\n     \"\"\"Uninstall the window compatibility monkey-patch.\n \n-    Restores the original .over() method to xorq's vendored ibis Value class.\n+    Restores the original methods:\n+    1. .over() methods to both xorq's and regular ibis Value classes\n+    2. window(), desc(), asc() functions to regular ibis module\n+\n     This is primarily useful for testing or cleanup purposes.\n \n     The uninstall only occurs if regular ibis is available and the patch\n@@ -190,5 +382,9 @@ def uninstall_window_compatibility():\n     global _patch_installed\n \n     if _IBIS_AVAILABLE and _patch_installed:\n-        XorqValue.over = _original_over\n+        XorqValue.over = _original_xorq_over\n+        ibis.expr.types.generic.Value.over = _original_ibis_over\n+        ibis.window = _original_ibis_window\n+        ibis.desc = _original_ibis_desc\n+        ibis.asc = _original_ibis_asc\n         _patch_installed = False\ndiff --git a/uv.lock b/uv.lock\nindex 77d169d..9926278 100644\n--- a/uv.lock\n+++ b/uv.lock\n@@ -260,6 +260,7 @@ viz-plotly = [\n [package.dev-dependencies]\n dev = [\n     { name = \"adbc-driver-sqlite\" },\n+    { name = \"ibis-framework\" },\n     { name = \"ipython\", version = \"8.37.0\", source = { registry = \"https://pypi.org/simple\" }, marker = \"python_full_version < '3.11'\" },\n     { name = \"ipython\", version = \"9.6.0\", source = { registry = \"https://pypi.org/simple\" }, marker = \"python_full_version >= '3.11'\" },\n     { name = \"xorq\" },\n@@ -296,6 +297,7 @@ provides-extras = [\"examples\", \"viz-altair\", \"viz-plotly\", \"viz-plotext\", \"dev\",\n [package.metadata.requires-dev]\n dev = [\n     { name = \"adbc-driver-sqlite\", specifier = \">=1.9.0\" },\n+    { name = \"ibis-framework\", specifier = \">=11.0.0\" },\n     { name = \"ipython\", specifier = \">=8.37.0\" },\n     { name = \"xorq\", specifier = \">=0.3.3\" },\n ]\n@@ -1155,6 +1157,24 @@ wheels = [\n     { url = \"https://files.pythonhosted.org/packages/d2/fd/6668e5aec43ab844de6fc74927e155a3b37bf40d7c3790e49fc0406b6578/httpx_sse-0.4.3-py3-none-any.whl\", hash = \"sha256:0ac1c9fe3c0afad2e0ebb25a934a59f4c7823b60792691f779fad2c5568830fc\", size = 8960, upload-time = \"2025-10-10T21:48:21.158Z\" },\n ]\n \n+[[package]]\n+name = \"ibis-framework\"\n+version = \"11.0.0\"\n+source = { registry = \"https://pypi.org/simple\" }\n+dependencies = [\n+    { name = \"atpublic\" },\n+    { name = \"parsy\" },\n+    { name = \"python-dateutil\" },\n+    { name = \"sqlglot\" },\n+    { name = \"toolz\" },\n+    { name = \"typing-extensions\" },\n+    { name = \"tzdata\" },\n+]\n+sdist = { url = \"https://files.pythonhosted.org/packages/93/c8/f03c7c6e8ab96e5efd67ea5ce6eaf575bde78b4bfb9115f283d5e6e19ea2/ibis_framework-11.0.0.tar.gz\", hash = \"sha256:0249185eaabb800e224f448cc06ce8ba168df00b269e132d62629f462eca8842\", size = 1237767, upload-time = \"2025-10-15T13:12:10.01Z\" }\n+wheels = [\n+    { url = \"https://files.pythonhosted.org/packages/86/c0/2851a8a55d0fea03b80fd45815069b686e032938fc68fa9d91ac776c148c/ibis_framework-11.0.0-py3-none-any.whl\", hash = \"sha256:92ff82a96f4eac7f86fa9b6a315e04b5a8f9ed3d186539d88f48e628363f2e72\", size = 1935652, upload-time = \"2025-10-15T13:12:07.954Z\" },\n+]\n+\n [[package]]\n name = \"identify\"\n version = \"2.6.15\""
  },
  "sys-version_info": [
    3,
    12,
    10,
    "final",
    0
  ]
}